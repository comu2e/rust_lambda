"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileAssetHandler = void 0;
const fs_1 = require("fs");
const path = require("path");
const cloud_assembly_schema_1 = require("@aws-cdk/cloud-assembly-schema");
const mime = require("mime");
const progress_1 = require("../../progress");
const archive_1 = require("../archive");
const fs_extra_1 = require("../fs-extra");
const placeholders_1 = require("../placeholders");
const shell_1 = require("../shell");
class FileAssetHandler {
    constructor(workDir, asset, host) {
        this.workDir = workDir;
        this.asset = asset;
        this.host = host;
        this.fileCacheRoot = path.join(workDir, '.cache');
    }
    async publish() {
        const destination = await placeholders_1.replaceAwsPlaceholders(this.asset.destination, this.host.aws);
        const s3Url = `s3://${destination.bucketName}/${destination.objectKey}`;
        const s3 = await this.host.aws.s3Client(destination);
        this.host.emitMessage(progress_1.EventType.CHECK, `Check ${s3Url}`);
        const bucketInfo = BucketInformation.for(this.host);
        // A thunk for describing the current account. Used when we need to format an error
        // message, not in the success case.
        const account = async () => { var _a; return (_a = (await this.host.aws.discoverTargetAccount(destination))) === null || _a === void 0 ? void 0 : _a.accountId; };
        switch (await bucketInfo.bucketOwnership(s3, destination.bucketName)) {
            case BucketOwnership.MINE:
                break;
            case BucketOwnership.DOES_NOT_EXIST:
                throw new Error(`No bucket named '${destination.bucketName}'. Is account ${await account()} bootstrapped?`);
            case BucketOwnership.SOMEONE_ELSES_OR_NO_ACCESS:
                throw new Error(`Bucket named '${destination.bucketName}' exists, but not in account ${await account()}. Wrong account?`);
        }
        if (await objectExists(s3, destination.bucketName, destination.objectKey)) {
            this.host.emitMessage(progress_1.EventType.FOUND, `Found ${s3Url}`);
            return;
        }
        // Identify the the bucket encryption type to set the header on upload
        // required for SCP rules denying uploads without encryption header
        let paramsEncryption = {};
        const encryption2 = await bucketInfo.bucketEncryption(s3, destination.bucketName);
        switch (encryption2) {
            case BucketEncryption.NO_ENCRYPTION:
                break;
            case BucketEncryption.SSEAlgorithm_AES256:
                paramsEncryption = { ServerSideEncryption: 'AES256' };
                break;
            case BucketEncryption.SSEAlgorithm_aws_kms:
                paramsEncryption = { ServerSideEncryption: 'aws:kms' };
                break;
            case BucketEncryption.DOES_NOT_EXIST:
                this.host.emitMessage(progress_1.EventType.DEBUG, `No bucket named '${destination.bucketName}'. Is account ${await account()} bootstrapped?`);
                break;
            case BucketEncryption.ACCES_DENIED:
                this.host.emitMessage(progress_1.EventType.DEBUG, `ACCES_DENIED for getting encryption of bucket '${destination.bucketName}'. Either wrong account ${await account()} or s3:GetEncryptionConfiguration not set for cdk role. Try "cdk bootstrap" again.`);
                break;
        }
        if (this.host.aborted) {
            return;
        }
        const publishFile = this.asset.source.executable ?
            await this.externalPackageFile(this.asset.source.executable) : await this.packageFile(this.asset.source);
        this.host.emitMessage(progress_1.EventType.UPLOAD, `Upload ${s3Url}`);
        const params = Object.assign({}, {
            Bucket: destination.bucketName,
            Key: destination.objectKey,
            Body: fs_1.createReadStream(publishFile.packagedPath),
            ContentType: publishFile.contentType,
        }, paramsEncryption);
        await s3.upload(params).promise();
    }
    async packageFile(source) {
        var _a;
        if (!source.path) {
            throw new Error(`'path' is expected in the File asset source, got: ${JSON.stringify(source)}`);
        }
        const fullPath = path.resolve(this.workDir, source.path);
        if (source.packaging === cloud_assembly_schema_1.FileAssetPackaging.ZIP_DIRECTORY) {
            const contentType = 'application/zip';
            await fs_1.promises.mkdir(this.fileCacheRoot, { recursive: true });
            const packagedPath = path.join(this.fileCacheRoot, `${this.asset.id.assetId}.zip`);
            if (await fs_extra_1.pathExists(packagedPath)) {
                this.host.emitMessage(progress_1.EventType.CACHED, `From cache ${path}`);
                return { packagedPath, contentType };
            }
            this.host.emitMessage(progress_1.EventType.BUILD, `Zip ${fullPath} -> ${path}`);
            await archive_1.zipDirectory(fullPath, packagedPath);
            return { packagedPath, contentType };
        }
        else {
            const contentType = (_a = mime.getType(fullPath)) !== null && _a !== void 0 ? _a : 'application/octet-stream';
            return { packagedPath: fullPath, contentType };
        }
    }
    async externalPackageFile(executable) {
        this.host.emitMessage(progress_1.EventType.BUILD, `Building asset source using command: '${executable}'`);
        return {
            packagedPath: (await shell_1.shell(executable, { quiet: true })).trim(),
            contentType: 'application/zip',
        };
    }
}
exports.FileAssetHandler = FileAssetHandler;
var BucketOwnership;
(function (BucketOwnership) {
    BucketOwnership[BucketOwnership["DOES_NOT_EXIST"] = 0] = "DOES_NOT_EXIST";
    BucketOwnership[BucketOwnership["MINE"] = 1] = "MINE";
    BucketOwnership[BucketOwnership["SOMEONE_ELSES_OR_NO_ACCESS"] = 2] = "SOMEONE_ELSES_OR_NO_ACCESS";
})(BucketOwnership || (BucketOwnership = {}));
var BucketEncryption;
(function (BucketEncryption) {
    BucketEncryption[BucketEncryption["NO_ENCRYPTION"] = 0] = "NO_ENCRYPTION";
    BucketEncryption[BucketEncryption["SSEAlgorithm_AES256"] = 1] = "SSEAlgorithm_AES256";
    BucketEncryption[BucketEncryption["SSEAlgorithm_aws_kms"] = 2] = "SSEAlgorithm_aws_kms";
    BucketEncryption[BucketEncryption["ACCES_DENIED"] = 3] = "ACCES_DENIED";
    BucketEncryption[BucketEncryption["DOES_NOT_EXIST"] = 4] = "DOES_NOT_EXIST";
})(BucketEncryption || (BucketEncryption = {}));
async function objectExists(s3, bucket, key) {
    /*
     * The object existence check here refrains from using the `headObject` operation because this
     * would create a negative cache entry, making GET-after-PUT eventually consistent. This has been
     * observed to result in CloudFormation issuing "ValidationError: S3 error: Access Denied", for
     * example in https://github.com/aws/aws-cdk/issues/6430.
     *
     * To prevent this, we are instead using the listObjectsV2 call, using the looked up key as the
     * prefix, and limiting results to 1. Since the list operation returns keys ordered by binary
     * UTF-8 representation, the key we are looking for is guaranteed to always be the first match
     * returned if it exists.
     */
    const response = await s3.listObjectsV2({ Bucket: bucket, Prefix: key, MaxKeys: 1 }).promise();
    return response.Contents != null && response.Contents.some(object => object.Key === key);
}
/**
 * Cache for bucket information, so we don't have to keep doing the same calls again and again
 *
 * We scope the lifetime of the cache to the lifetime of the host, so that we don't have to do
 * anything special for tests and yet the cache will live for the entire lifetime of the asset
 * upload session when used by the CLI.
 */
class BucketInformation {
    constructor() {
        this.ownerships = new Map();
        this.encryptions = new Map();
    }
    static for(host) {
        const existing = BucketInformation.caches.get(host);
        if (existing) {
            return existing;
        }
        const fresh = new BucketInformation();
        BucketInformation.caches.set(host, fresh);
        return fresh;
    }
    async bucketOwnership(s3, bucket) {
        return cached(this.ownerships, bucket, () => this._bucketOwnership(s3, bucket));
    }
    async bucketEncryption(s3, bucket) {
        return cached(this.encryptions, bucket, () => this._bucketEncryption(s3, bucket));
    }
    async _bucketOwnership(s3, bucket) {
        try {
            await s3.getBucketLocation({ Bucket: bucket }).promise();
            return BucketOwnership.MINE;
        }
        catch (e) {
            if (e.code === 'NoSuchBucket') {
                return BucketOwnership.DOES_NOT_EXIST;
            }
            if (['AccessDenied', 'AllAccessDisabled'].includes(e.code)) {
                return BucketOwnership.SOMEONE_ELSES_OR_NO_ACCESS;
            }
            throw e;
        }
    }
    async _bucketEncryption(s3, bucket) {
        var _a, _b, _c, _d, _e, _f;
        try {
            const encryption = await s3.getBucketEncryption({ Bucket: bucket }).promise();
            const l = (_c = (_b = (_a = encryption === null || encryption === void 0 ? void 0 : encryption.ServerSideEncryptionConfiguration) === null || _a === void 0 ? void 0 : _a.Rules) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;
            if (l > 0) {
                let ssealgo = (_f = (_e = (_d = encryption === null || encryption === void 0 ? void 0 : encryption.ServerSideEncryptionConfiguration) === null || _d === void 0 ? void 0 : _d.Rules[0]) === null || _e === void 0 ? void 0 : _e.ApplyServerSideEncryptionByDefault) === null || _f === void 0 ? void 0 : _f.SSEAlgorithm;
                if (ssealgo === 'AES256')
                    return BucketEncryption.SSEAlgorithm_AES256;
                if (ssealgo === 'aws:kms')
                    return BucketEncryption.SSEAlgorithm_aws_kms;
            }
            return BucketEncryption.NO_ENCRYPTION;
        }
        catch (e) {
            if (e.code === 'NoSuchBucket') {
                return BucketEncryption.DOES_NOT_EXIST;
            }
            if (e.code === 'ServerSideEncryptionConfigurationNotFoundError') {
                return BucketEncryption.NO_ENCRYPTION;
            }
            if (['AccessDenied', 'AllAccessDisabled'].includes(e.code)) {
                return BucketEncryption.ACCES_DENIED;
            }
            return BucketEncryption.NO_ENCRYPTION;
        }
    }
}
BucketInformation.caches = new WeakMap();
async function cached(cache, key, factory) {
    if (cache.has(key)) {
        return cache.get(key);
    }
    const fresh = await factory(key);
    cache.set(key, fresh);
    return fresh;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJmaWxlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSwyQkFBc0Q7QUFDdEQsNkJBQTZCO0FBQzdCLDBFQUFnRjtBQUNoRiw2QkFBNkI7QUFFN0IsNkNBQTJDO0FBQzNDLHdDQUEwQztBQUUxQywwQ0FBeUM7QUFDekMsa0RBQXlEO0FBQ3pELG9DQUFpQztBQUVqQyxNQUFhLGdCQUFnQjtJQUczQixZQUNtQixPQUFlLEVBQ2YsS0FBd0IsRUFDeEIsSUFBa0I7UUFGbEIsWUFBTyxHQUFQLE9BQU8sQ0FBUTtRQUNmLFVBQUssR0FBTCxLQUFLLENBQW1CO1FBQ3hCLFNBQUksR0FBSixJQUFJLENBQWM7UUFDbkMsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQztJQUNwRCxDQUFDO0lBRU0sS0FBSyxDQUFDLE9BQU87UUFDbEIsTUFBTSxXQUFXLEdBQUcsTUFBTSxxQ0FBc0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3hGLE1BQU0sS0FBSyxHQUFHLFFBQVEsV0FBVyxDQUFDLFVBQVUsSUFBSSxXQUFXLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDeEUsTUFBTSxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDckQsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsb0JBQVMsQ0FBQyxLQUFLLEVBQUUsU0FBUyxLQUFLLEVBQUUsQ0FBQyxDQUFDO1FBRXpELE1BQU0sVUFBVSxHQUFHLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFcEQsbUZBQW1GO1FBQ25GLG9DQUFvQztRQUNwQyxNQUFNLE9BQU8sR0FBRyxLQUFLLElBQUksRUFBRSx3QkFBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMscUJBQXFCLENBQUMsV0FBVyxDQUFDLENBQUMsMENBQUUsU0FBUyxHQUFBLENBQUM7UUFDaEcsUUFBUSxNQUFNLFVBQVUsQ0FBQyxlQUFlLENBQUMsRUFBRSxFQUFFLFdBQVcsQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUNwRSxLQUFLLGVBQWUsQ0FBQyxJQUFJO2dCQUN2QixNQUFNO1lBQ1IsS0FBSyxlQUFlLENBQUMsY0FBYztnQkFDakMsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQkFBb0IsV0FBVyxDQUFDLFVBQVUsaUJBQWlCLE1BQU0sT0FBTyxFQUFFLGdCQUFnQixDQUFDLENBQUM7WUFDOUcsS0FBSyxlQUFlLENBQUMsMEJBQTBCO2dCQUM3QyxNQUFNLElBQUksS0FBSyxDQUFDLGlCQUFpQixXQUFXLENBQUMsVUFBVSxnQ0FBZ0MsTUFBTSxPQUFPLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztTQUM3SDtRQUVELElBQUksTUFBTSxZQUFZLENBQUMsRUFBRSxFQUFFLFdBQVcsQ0FBQyxVQUFVLEVBQUUsV0FBVyxDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQ3pFLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLG9CQUFTLENBQUMsS0FBSyxFQUFFLFNBQVMsS0FBSyxFQUFFLENBQUMsQ0FBQztZQUN6RCxPQUFPO1NBQ1I7UUFFRCxzRUFBc0U7UUFDdEUsbUVBQW1FO1FBQ25FLElBQUksZ0JBQWdCLEdBQXlCLEVBQUUsQ0FBQztRQUNoRCxNQUFNLFdBQVcsR0FBRyxNQUFNLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLEVBQUUsV0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2xGLFFBQVEsV0FBVyxFQUFFO1lBQ25CLEtBQUssZ0JBQWdCLENBQUMsYUFBYTtnQkFDakMsTUFBTTtZQUNSLEtBQUssZ0JBQWdCLENBQUMsbUJBQW1CO2dCQUN2QyxnQkFBZ0IsR0FBRyxFQUFFLG9CQUFvQixFQUFFLFFBQVEsRUFBRSxDQUFDO2dCQUN0RCxNQUFNO1lBQ1IsS0FBSyxnQkFBZ0IsQ0FBQyxvQkFBb0I7Z0JBQ3hDLGdCQUFnQixHQUFHLEVBQUUsb0JBQW9CLEVBQUUsU0FBUyxFQUFFLENBQUM7Z0JBQ3ZELE1BQU07WUFDUixLQUFLLGdCQUFnQixDQUFDLGNBQWM7Z0JBQ2xDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLG9CQUFTLENBQUMsS0FBSyxFQUFFLG9CQUFvQixXQUFXLENBQUMsVUFBVSxpQkFBaUIsTUFBTSxPQUFPLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztnQkFDbkksTUFBTTtZQUNSLEtBQUssZ0JBQWdCLENBQUMsWUFBWTtnQkFDaEMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsb0JBQVMsQ0FBQyxLQUFLLEVBQUUsa0RBQWtELFdBQVcsQ0FBQyxVQUFVLDJCQUEyQixNQUFNLE9BQU8sRUFBRSxvRkFBb0YsQ0FBQyxDQUFDO2dCQUMvTyxNQUFNO1NBQ1Q7UUFFRCxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQUUsT0FBTztTQUFFO1FBQ2xDLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ2hELE1BQU0sSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUUzRyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxvQkFBUyxDQUFDLE1BQU0sRUFBRSxVQUFVLEtBQUssRUFBRSxDQUFDLENBQUM7UUFFM0QsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUU7WUFDL0IsTUFBTSxFQUFFLFdBQVcsQ0FBQyxVQUFVO1lBQzlCLEdBQUcsRUFBRSxXQUFXLENBQUMsU0FBUztZQUMxQixJQUFJLEVBQUUscUJBQWdCLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQztZQUNoRCxXQUFXLEVBQUUsV0FBVyxDQUFDLFdBQVc7U0FDckMsRUFDRCxnQkFBZ0IsQ0FBQyxDQUFDO1FBRWxCLE1BQU0sRUFBRSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUNwQyxDQUFDO0lBRU8sS0FBSyxDQUFDLFdBQVcsQ0FBQyxNQUFrQjs7UUFDMUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUU7WUFDaEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxxREFBcUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDaEc7UUFFRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXpELElBQUksTUFBTSxDQUFDLFNBQVMsS0FBSywwQ0FBa0IsQ0FBQyxhQUFhLEVBQUU7WUFDekQsTUFBTSxXQUFXLEdBQUcsaUJBQWlCLENBQUM7WUFFdEMsTUFBTSxhQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztZQUN4RCxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxPQUFPLE1BQU0sQ0FBQyxDQUFDO1lBRW5GLElBQUksTUFBTSxxQkFBVSxDQUFDLFlBQVksQ0FBQyxFQUFFO2dCQUNsQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxvQkFBUyxDQUFDLE1BQU0sRUFBRSxjQUFjLElBQUksRUFBRSxDQUFDLENBQUM7Z0JBQzlELE9BQU8sRUFBRSxZQUFZLEVBQUUsV0FBVyxFQUFFLENBQUM7YUFDdEM7WUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxvQkFBUyxDQUFDLEtBQUssRUFBRSxPQUFPLFFBQVEsT0FBTyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1lBQ3JFLE1BQU0sc0JBQVksQ0FBQyxRQUFRLEVBQUUsWUFBWSxDQUFDLENBQUM7WUFDM0MsT0FBTyxFQUFFLFlBQVksRUFBRSxXQUFXLEVBQUUsQ0FBQztTQUN0QzthQUFNO1lBQ0wsTUFBTSxXQUFXLFNBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsbUNBQUksMEJBQTBCLENBQUM7WUFDekUsT0FBTyxFQUFFLFlBQVksRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLENBQUM7U0FDaEQ7SUFDSCxDQUFDO0lBRU8sS0FBSyxDQUFDLG1CQUFtQixDQUFDLFVBQW9CO1FBQ3BELElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLG9CQUFTLENBQUMsS0FBSyxFQUFFLHlDQUF5QyxVQUFVLEdBQUcsQ0FBQyxDQUFDO1FBRS9GLE9BQU87WUFDTCxZQUFZLEVBQUUsQ0FBQyxNQUFNLGFBQUssQ0FBQyxVQUFVLEVBQUUsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRTtZQUMvRCxXQUFXLEVBQUUsaUJBQWlCO1NBQy9CLENBQUM7SUFDSixDQUFDO0NBQ0Y7QUE1R0QsNENBNEdDO0FBRUQsSUFBSyxlQUlKO0FBSkQsV0FBSyxlQUFlO0lBQ2xCLHlFQUFjLENBQUE7SUFDZCxxREFBSSxDQUFBO0lBQ0osaUdBQTBCLENBQUE7QUFDNUIsQ0FBQyxFQUpJLGVBQWUsS0FBZixlQUFlLFFBSW5CO0FBRUQsSUFBSyxnQkFNSjtBQU5ELFdBQUssZ0JBQWdCO0lBQ25CLHlFQUFhLENBQUE7SUFDYixxRkFBbUIsQ0FBQTtJQUNuQix1RkFBb0IsQ0FBQTtJQUNwQix1RUFBWSxDQUFBO0lBQ1osMkVBQWMsQ0FBQTtBQUNoQixDQUFDLEVBTkksZ0JBQWdCLEtBQWhCLGdCQUFnQixRQU1wQjtBQUVELEtBQUssVUFBVSxZQUFZLENBQUMsRUFBVSxFQUFFLE1BQWMsRUFBRSxHQUFXO0lBQ2pFOzs7Ozs7Ozs7O09BVUc7SUFDSCxNQUFNLFFBQVEsR0FBRyxNQUFNLEVBQUUsQ0FBQyxhQUFhLENBQUMsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDL0YsT0FBTyxRQUFRLENBQUMsUUFBUSxJQUFJLElBQUksSUFBSSxRQUFRLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUM7QUFDM0YsQ0FBQztBQXFCRDs7Ozs7O0dBTUc7QUFDSCxNQUFNLGlCQUFpQjtJQWVyQjtRQUhpQixlQUFVLEdBQUcsSUFBSSxHQUFHLEVBQTJCLENBQUM7UUFDaEQsZ0JBQVcsR0FBRyxJQUFJLEdBQUcsRUFBNEIsQ0FBQztJQUduRSxDQUFDO0lBZk0sTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFrQjtRQUNsQyxNQUFNLFFBQVEsR0FBRyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3BELElBQUksUUFBUSxFQUFFO1lBQUUsT0FBTyxRQUFRLENBQUM7U0FBRTtRQUVsQyxNQUFNLEtBQUssR0FBRyxJQUFJLGlCQUFpQixFQUFFLENBQUM7UUFDdEMsaUJBQWlCLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDMUMsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBVU0sS0FBSyxDQUFDLGVBQWUsQ0FBQyxFQUFVLEVBQUUsTUFBYztRQUNyRCxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDbEYsQ0FBQztJQUVNLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFVLEVBQUUsTUFBYztRQUN0RCxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDcEYsQ0FBQztJQUVPLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFVLEVBQUUsTUFBYztRQUN2RCxJQUFJO1lBQ0YsTUFBTSxFQUFFLENBQUMsaUJBQWlCLENBQUMsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUN6RCxPQUFPLGVBQWUsQ0FBQyxJQUFJLENBQUM7U0FDN0I7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxjQUFjLEVBQUU7Z0JBQUUsT0FBTyxlQUFlLENBQUMsY0FBYyxDQUFDO2FBQUU7WUFDekUsSUFBSSxDQUFDLGNBQWMsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQUUsT0FBTyxlQUFlLENBQUMsMEJBQTBCLENBQUM7YUFBRTtZQUNsSCxNQUFNLENBQUMsQ0FBQztTQUNUO0lBQ0gsQ0FBQztJQUVPLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxFQUFVLEVBQUUsTUFBYzs7UUFDeEQsSUFBSTtZQUNGLE1BQU0sVUFBVSxHQUFHLE1BQU0sRUFBRSxDQUFDLG1CQUFtQixDQUFDLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDOUUsTUFBTSxDQUFDLHFCQUFHLFVBQVUsYUFBVixVQUFVLHVCQUFWLFVBQVUsQ0FBRSxpQ0FBaUMsMENBQUUsS0FBSywwQ0FBRSxNQUFNLG1DQUFJLENBQUMsQ0FBQztZQUM1RSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQ1QsSUFBSSxPQUFPLHFCQUFHLFVBQVUsYUFBVixVQUFVLHVCQUFWLFVBQVUsQ0FBRSxpQ0FBaUMsMENBQUUsS0FBSyxDQUFDLENBQUMsMkNBQUcsa0NBQWtDLDBDQUFFLFlBQVksQ0FBQztnQkFDeEgsSUFBSSxPQUFPLEtBQUssUUFBUTtvQkFBRSxPQUFPLGdCQUFnQixDQUFDLG1CQUFtQixDQUFDO2dCQUN0RSxJQUFJLE9BQU8sS0FBSyxTQUFTO29CQUFFLE9BQU8sZ0JBQWdCLENBQUMsb0JBQW9CLENBQUM7YUFDekU7WUFDRCxPQUFPLGdCQUFnQixDQUFDLGFBQWEsQ0FBQztTQUN2QztRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLGNBQWMsRUFBRTtnQkFDN0IsT0FBTyxnQkFBZ0IsQ0FBQyxjQUFjLENBQUM7YUFDeEM7WUFDRCxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssZ0RBQWdELEVBQUU7Z0JBQy9ELE9BQU8sZ0JBQWdCLENBQUMsYUFBYSxDQUFDO2FBQ3ZDO1lBRUQsSUFBSSxDQUFDLGNBQWMsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQzFELE9BQU8sZ0JBQWdCLENBQUMsWUFBWSxDQUFDO2FBQ3RDO1lBQ0QsT0FBTyxnQkFBZ0IsQ0FBQyxhQUFhLENBQUM7U0FDdkM7SUFDSCxDQUFDOztBQWxEdUIsd0JBQU0sR0FBRyxJQUFJLE9BQU8sRUFBbUMsQ0FBQztBQXFEbEYsS0FBSyxVQUFVLE1BQU0sQ0FBTyxLQUFnQixFQUFFLEdBQU0sRUFBRSxPQUE2QjtJQUNqRixJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDbEIsT0FBTyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBRSxDQUFDO0tBQ3hCO0lBRUQsTUFBTSxLQUFLLEdBQUcsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDakMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDdEIsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlUmVhZFN0cmVhbSwgcHJvbWlzZXMgYXMgZnMgfSBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgRmlsZUFzc2V0UGFja2FnaW5nLCBGaWxlU291cmNlIH0gZnJvbSAnQGF3cy1jZGsvY2xvdWQtYXNzZW1ibHktc2NoZW1hJztcbmltcG9ydCAqIGFzIG1pbWUgZnJvbSAnbWltZSc7XG5pbXBvcnQgeyBGaWxlTWFuaWZlc3RFbnRyeSB9IGZyb20gJy4uLy4uL2Fzc2V0LW1hbmlmZXN0JztcbmltcG9ydCB7IEV2ZW50VHlwZSB9IGZyb20gJy4uLy4uL3Byb2dyZXNzJztcbmltcG9ydCB7IHppcERpcmVjdG9yeSB9IGZyb20gJy4uL2FyY2hpdmUnO1xuaW1wb3J0IHsgSUFzc2V0SGFuZGxlciwgSUhhbmRsZXJIb3N0IH0gZnJvbSAnLi4vYXNzZXQtaGFuZGxlcic7XG5pbXBvcnQgeyBwYXRoRXhpc3RzIH0gZnJvbSAnLi4vZnMtZXh0cmEnO1xuaW1wb3J0IHsgcmVwbGFjZUF3c1BsYWNlaG9sZGVycyB9IGZyb20gJy4uL3BsYWNlaG9sZGVycyc7XG5pbXBvcnQgeyBzaGVsbCB9IGZyb20gJy4uL3NoZWxsJztcblxuZXhwb3J0IGNsYXNzIEZpbGVBc3NldEhhbmRsZXIgaW1wbGVtZW50cyBJQXNzZXRIYW5kbGVyIHtcbiAgcHJpdmF0ZSByZWFkb25seSBmaWxlQ2FjaGVSb290OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSB3b3JrRGlyOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBhc3NldDogRmlsZU1hbmlmZXN0RW50cnksXG4gICAgcHJpdmF0ZSByZWFkb25seSBob3N0OiBJSGFuZGxlckhvc3QpIHtcbiAgICB0aGlzLmZpbGVDYWNoZVJvb3QgPSBwYXRoLmpvaW4od29ya0RpciwgJy5jYWNoZScpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHB1Ymxpc2goKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgZGVzdGluYXRpb24gPSBhd2FpdCByZXBsYWNlQXdzUGxhY2Vob2xkZXJzKHRoaXMuYXNzZXQuZGVzdGluYXRpb24sIHRoaXMuaG9zdC5hd3MpO1xuICAgIGNvbnN0IHMzVXJsID0gYHMzOi8vJHtkZXN0aW5hdGlvbi5idWNrZXROYW1lfS8ke2Rlc3RpbmF0aW9uLm9iamVjdEtleX1gO1xuICAgIGNvbnN0IHMzID0gYXdhaXQgdGhpcy5ob3N0LmF3cy5zM0NsaWVudChkZXN0aW5hdGlvbik7XG4gICAgdGhpcy5ob3N0LmVtaXRNZXNzYWdlKEV2ZW50VHlwZS5DSEVDSywgYENoZWNrICR7czNVcmx9YCk7XG5cbiAgICBjb25zdCBidWNrZXRJbmZvID0gQnVja2V0SW5mb3JtYXRpb24uZm9yKHRoaXMuaG9zdCk7XG5cbiAgICAvLyBBIHRodW5rIGZvciBkZXNjcmliaW5nIHRoZSBjdXJyZW50IGFjY291bnQuIFVzZWQgd2hlbiB3ZSBuZWVkIHRvIGZvcm1hdCBhbiBlcnJvclxuICAgIC8vIG1lc3NhZ2UsIG5vdCBpbiB0aGUgc3VjY2VzcyBjYXNlLlxuICAgIGNvbnN0IGFjY291bnQgPSBhc3luYyAoKSA9PiAoYXdhaXQgdGhpcy5ob3N0LmF3cy5kaXNjb3ZlclRhcmdldEFjY291bnQoZGVzdGluYXRpb24pKT8uYWNjb3VudElkO1xuICAgIHN3aXRjaCAoYXdhaXQgYnVja2V0SW5mby5idWNrZXRPd25lcnNoaXAoczMsIGRlc3RpbmF0aW9uLmJ1Y2tldE5hbWUpKSB7XG4gICAgICBjYXNlIEJ1Y2tldE93bmVyc2hpcC5NSU5FOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQnVja2V0T3duZXJzaGlwLkRPRVNfTk9UX0VYSVNUOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGJ1Y2tldCBuYW1lZCAnJHtkZXN0aW5hdGlvbi5idWNrZXROYW1lfScuIElzIGFjY291bnQgJHthd2FpdCBhY2NvdW50KCl9IGJvb3RzdHJhcHBlZD9gKTtcbiAgICAgIGNhc2UgQnVja2V0T3duZXJzaGlwLlNPTUVPTkVfRUxTRVNfT1JfTk9fQUNDRVNTOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJ1Y2tldCBuYW1lZCAnJHtkZXN0aW5hdGlvbi5idWNrZXROYW1lfScgZXhpc3RzLCBidXQgbm90IGluIGFjY291bnQgJHthd2FpdCBhY2NvdW50KCl9LiBXcm9uZyBhY2NvdW50P2ApO1xuICAgIH1cblxuICAgIGlmIChhd2FpdCBvYmplY3RFeGlzdHMoczMsIGRlc3RpbmF0aW9uLmJ1Y2tldE5hbWUsIGRlc3RpbmF0aW9uLm9iamVjdEtleSkpIHtcbiAgICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuRk9VTkQsIGBGb3VuZCAke3MzVXJsfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElkZW50aWZ5IHRoZSB0aGUgYnVja2V0IGVuY3J5cHRpb24gdHlwZSB0byBzZXQgdGhlIGhlYWRlciBvbiB1cGxvYWRcbiAgICAvLyByZXF1aXJlZCBmb3IgU0NQIHJ1bGVzIGRlbnlpbmcgdXBsb2FkcyB3aXRob3V0IGVuY3J5cHRpb24gaGVhZGVyXG4gICAgbGV0IHBhcmFtc0VuY3J5cHRpb246IHtbaW5kZXg6IHN0cmluZ106YW55fT0ge307XG4gICAgY29uc3QgZW5jcnlwdGlvbjIgPSBhd2FpdCBidWNrZXRJbmZvLmJ1Y2tldEVuY3J5cHRpb24oczMsIGRlc3RpbmF0aW9uLmJ1Y2tldE5hbWUpO1xuICAgIHN3aXRjaCAoZW5jcnlwdGlvbjIpIHtcbiAgICAgIGNhc2UgQnVja2V0RW5jcnlwdGlvbi5OT19FTkNSWVBUSU9OOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQnVja2V0RW5jcnlwdGlvbi5TU0VBbGdvcml0aG1fQUVTMjU2OlxuICAgICAgICBwYXJhbXNFbmNyeXB0aW9uID0geyBTZXJ2ZXJTaWRlRW5jcnlwdGlvbjogJ0FFUzI1NicgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEJ1Y2tldEVuY3J5cHRpb24uU1NFQWxnb3JpdGhtX2F3c19rbXM6XG4gICAgICAgIHBhcmFtc0VuY3J5cHRpb24gPSB7IFNlcnZlclNpZGVFbmNyeXB0aW9uOiAnYXdzOmttcycgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEJ1Y2tldEVuY3J5cHRpb24uRE9FU19OT1RfRVhJU1Q6XG4gICAgICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuREVCVUcsIGBObyBidWNrZXQgbmFtZWQgJyR7ZGVzdGluYXRpb24uYnVja2V0TmFtZX0nLiBJcyBhY2NvdW50ICR7YXdhaXQgYWNjb3VudCgpfSBib290c3RyYXBwZWQ/YCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBCdWNrZXRFbmNyeXB0aW9uLkFDQ0VTX0RFTklFRDpcbiAgICAgICAgdGhpcy5ob3N0LmVtaXRNZXNzYWdlKEV2ZW50VHlwZS5ERUJVRywgYEFDQ0VTX0RFTklFRCBmb3IgZ2V0dGluZyBlbmNyeXB0aW9uIG9mIGJ1Y2tldCAnJHtkZXN0aW5hdGlvbi5idWNrZXROYW1lfScuIEVpdGhlciB3cm9uZyBhY2NvdW50ICR7YXdhaXQgYWNjb3VudCgpfSBvciBzMzpHZXRFbmNyeXB0aW9uQ29uZmlndXJhdGlvbiBub3Qgc2V0IGZvciBjZGsgcm9sZS4gVHJ5IFwiY2RrIGJvb3RzdHJhcFwiIGFnYWluLmApO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0LmFib3J0ZWQpIHsgcmV0dXJuOyB9XG4gICAgY29uc3QgcHVibGlzaEZpbGUgPSB0aGlzLmFzc2V0LnNvdXJjZS5leGVjdXRhYmxlID9cbiAgICAgIGF3YWl0IHRoaXMuZXh0ZXJuYWxQYWNrYWdlRmlsZSh0aGlzLmFzc2V0LnNvdXJjZS5leGVjdXRhYmxlKSA6IGF3YWl0IHRoaXMucGFja2FnZUZpbGUodGhpcy5hc3NldC5zb3VyY2UpO1xuXG4gICAgdGhpcy5ob3N0LmVtaXRNZXNzYWdlKEV2ZW50VHlwZS5VUExPQUQsIGBVcGxvYWQgJHtzM1VybH1gKTtcblxuICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgIEJ1Y2tldDogZGVzdGluYXRpb24uYnVja2V0TmFtZSxcbiAgICAgIEtleTogZGVzdGluYXRpb24ub2JqZWN0S2V5LFxuICAgICAgQm9keTogY3JlYXRlUmVhZFN0cmVhbShwdWJsaXNoRmlsZS5wYWNrYWdlZFBhdGgpLFxuICAgICAgQ29udGVudFR5cGU6IHB1Ymxpc2hGaWxlLmNvbnRlbnRUeXBlLFxuICAgIH0sXG4gICAgcGFyYW1zRW5jcnlwdGlvbik7XG5cbiAgICBhd2FpdCBzMy51cGxvYWQocGFyYW1zKS5wcm9taXNlKCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHBhY2thZ2VGaWxlKHNvdXJjZTogRmlsZVNvdXJjZSk6IFByb21pc2U8UGFja2FnZWRGaWxlQXNzZXQ+IHtcbiAgICBpZiAoIXNvdXJjZS5wYXRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCdwYXRoJyBpcyBleHBlY3RlZCBpbiB0aGUgRmlsZSBhc3NldCBzb3VyY2UsIGdvdDogJHtKU09OLnN0cmluZ2lmeShzb3VyY2UpfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aC5yZXNvbHZlKHRoaXMud29ya0Rpciwgc291cmNlLnBhdGgpO1xuXG4gICAgaWYgKHNvdXJjZS5wYWNrYWdpbmcgPT09IEZpbGVBc3NldFBhY2thZ2luZy5aSVBfRElSRUNUT1JZKSB7XG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi96aXAnO1xuXG4gICAgICBhd2FpdCBmcy5ta2Rpcih0aGlzLmZpbGVDYWNoZVJvb3QsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgY29uc3QgcGFja2FnZWRQYXRoID0gcGF0aC5qb2luKHRoaXMuZmlsZUNhY2hlUm9vdCwgYCR7dGhpcy5hc3NldC5pZC5hc3NldElkfS56aXBgKTtcblxuICAgICAgaWYgKGF3YWl0IHBhdGhFeGlzdHMocGFja2FnZWRQYXRoKSkge1xuICAgICAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkNBQ0hFRCwgYEZyb20gY2FjaGUgJHtwYXRofWApO1xuICAgICAgICByZXR1cm4geyBwYWNrYWdlZFBhdGgsIGNvbnRlbnRUeXBlIH07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuQlVJTEQsIGBaaXAgJHtmdWxsUGF0aH0gLT4gJHtwYXRofWApO1xuICAgICAgYXdhaXQgemlwRGlyZWN0b3J5KGZ1bGxQYXRoLCBwYWNrYWdlZFBhdGgpO1xuICAgICAgcmV0dXJuIHsgcGFja2FnZWRQYXRoLCBjb250ZW50VHlwZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9IG1pbWUuZ2V0VHlwZShmdWxsUGF0aCkgPz8gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG4gICAgICByZXR1cm4geyBwYWNrYWdlZFBhdGg6IGZ1bGxQYXRoLCBjb250ZW50VHlwZSB9O1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZXh0ZXJuYWxQYWNrYWdlRmlsZShleGVjdXRhYmxlOiBzdHJpbmdbXSk6IFByb21pc2U8UGFja2FnZWRGaWxlQXNzZXQ+IHtcbiAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkJVSUxELCBgQnVpbGRpbmcgYXNzZXQgc291cmNlIHVzaW5nIGNvbW1hbmQ6ICcke2V4ZWN1dGFibGV9J2ApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhY2thZ2VkUGF0aDogKGF3YWl0IHNoZWxsKGV4ZWN1dGFibGUsIHsgcXVpZXQ6IHRydWUgfSkpLnRyaW0oKSxcbiAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vemlwJyxcbiAgICB9O1xuICB9XG59XG5cbmVudW0gQnVja2V0T3duZXJzaGlwIHtcbiAgRE9FU19OT1RfRVhJU1QsXG4gIE1JTkUsXG4gIFNPTUVPTkVfRUxTRVNfT1JfTk9fQUNDRVNTXG59XG5cbmVudW0gQnVja2V0RW5jcnlwdGlvbiB7XG4gIE5PX0VOQ1JZUFRJT04sXG4gIFNTRUFsZ29yaXRobV9BRVMyNTYsXG4gIFNTRUFsZ29yaXRobV9hd3Nfa21zLFxuICBBQ0NFU19ERU5JRUQsXG4gIERPRVNfTk9UX0VYSVNUXG59XG5cbmFzeW5jIGZ1bmN0aW9uIG9iamVjdEV4aXN0cyhzMzogQVdTLlMzLCBidWNrZXQ6IHN0cmluZywga2V5OiBzdHJpbmcpIHtcbiAgLypcbiAgICogVGhlIG9iamVjdCBleGlzdGVuY2UgY2hlY2sgaGVyZSByZWZyYWlucyBmcm9tIHVzaW5nIHRoZSBgaGVhZE9iamVjdGAgb3BlcmF0aW9uIGJlY2F1c2UgdGhpc1xuICAgKiB3b3VsZCBjcmVhdGUgYSBuZWdhdGl2ZSBjYWNoZSBlbnRyeSwgbWFraW5nIEdFVC1hZnRlci1QVVQgZXZlbnR1YWxseSBjb25zaXN0ZW50LiBUaGlzIGhhcyBiZWVuXG4gICAqIG9ic2VydmVkIHRvIHJlc3VsdCBpbiBDbG91ZEZvcm1hdGlvbiBpc3N1aW5nIFwiVmFsaWRhdGlvbkVycm9yOiBTMyBlcnJvcjogQWNjZXNzIERlbmllZFwiLCBmb3JcbiAgICogZXhhbXBsZSBpbiBodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1jZGsvaXNzdWVzLzY0MzAuXG4gICAqXG4gICAqIFRvIHByZXZlbnQgdGhpcywgd2UgYXJlIGluc3RlYWQgdXNpbmcgdGhlIGxpc3RPYmplY3RzVjIgY2FsbCwgdXNpbmcgdGhlIGxvb2tlZCB1cCBrZXkgYXMgdGhlXG4gICAqIHByZWZpeCwgYW5kIGxpbWl0aW5nIHJlc3VsdHMgdG8gMS4gU2luY2UgdGhlIGxpc3Qgb3BlcmF0aW9uIHJldHVybnMga2V5cyBvcmRlcmVkIGJ5IGJpbmFyeVxuICAgKiBVVEYtOCByZXByZXNlbnRhdGlvbiwgdGhlIGtleSB3ZSBhcmUgbG9va2luZyBmb3IgaXMgZ3VhcmFudGVlZCB0byBhbHdheXMgYmUgdGhlIGZpcnN0IG1hdGNoXG4gICAqIHJldHVybmVkIGlmIGl0IGV4aXN0cy5cbiAgICovXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgczMubGlzdE9iamVjdHNWMih7IEJ1Y2tldDogYnVja2V0LCBQcmVmaXg6IGtleSwgTWF4S2V5czogMSB9KS5wcm9taXNlKCk7XG4gIHJldHVybiByZXNwb25zZS5Db250ZW50cyAhPSBudWxsICYmIHJlc3BvbnNlLkNvbnRlbnRzLnNvbWUob2JqZWN0ID0+IG9iamVjdC5LZXkgPT09IGtleSk7XG59XG5cblxuLyoqXG4gKiBBIHBhY2thZ2VkIGFzc2V0IHdoaWNoIGNhbiBiZSB1cGxvYWRlZCAoZWl0aGVyIGEgc2luZ2xlIGZpbGUgb3IgZGlyZWN0b3J5KVxuICovXG5pbnRlcmZhY2UgUGFja2FnZWRGaWxlQXNzZXQge1xuICAvKipcbiAgICogUGF0aCBvZiB0aGUgZmlsZSBvciBkaXJlY3RvcnlcbiAgICovXG4gIHJlYWRvbmx5IHBhY2thZ2VkUGF0aDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDb250ZW50IHR5cGUgdG8gYmUgYWRkZWQgaW4gdGhlIFMzIHVwbG9hZCBhY3Rpb25cbiAgICpcbiAgICogQGRlZmF1bHQgLSBObyBjb250ZW50IHR5cGVcbiAgICovXG4gIHJlYWRvbmx5IGNvbnRlbnRUeXBlPzogc3RyaW5nO1xufVxuXG5cbi8qKlxuICogQ2FjaGUgZm9yIGJ1Y2tldCBpbmZvcm1hdGlvbiwgc28gd2UgZG9uJ3QgaGF2ZSB0byBrZWVwIGRvaW5nIHRoZSBzYW1lIGNhbGxzIGFnYWluIGFuZCBhZ2FpblxuICpcbiAqIFdlIHNjb3BlIHRoZSBsaWZldGltZSBvZiB0aGUgY2FjaGUgdG8gdGhlIGxpZmV0aW1lIG9mIHRoZSBob3N0LCBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gZG9cbiAqIGFueXRoaW5nIHNwZWNpYWwgZm9yIHRlc3RzIGFuZCB5ZXQgdGhlIGNhY2hlIHdpbGwgbGl2ZSBmb3IgdGhlIGVudGlyZSBsaWZldGltZSBvZiB0aGUgYXNzZXRcbiAqIHVwbG9hZCBzZXNzaW9uIHdoZW4gdXNlZCBieSB0aGUgQ0xJLlxuICovXG5jbGFzcyBCdWNrZXRJbmZvcm1hdGlvbiB7XG4gIHB1YmxpYyBzdGF0aWMgZm9yKGhvc3Q6IElIYW5kbGVySG9zdCkge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gQnVja2V0SW5mb3JtYXRpb24uY2FjaGVzLmdldChob3N0KTtcbiAgICBpZiAoZXhpc3RpbmcpIHsgcmV0dXJuIGV4aXN0aW5nOyB9XG5cbiAgICBjb25zdCBmcmVzaCA9IG5ldyBCdWNrZXRJbmZvcm1hdGlvbigpO1xuICAgIEJ1Y2tldEluZm9ybWF0aW9uLmNhY2hlcy5zZXQoaG9zdCwgZnJlc2gpO1xuICAgIHJldHVybiBmcmVzaDtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IGNhY2hlcyA9IG5ldyBXZWFrTWFwPElIYW5kbGVySG9zdCwgQnVja2V0SW5mb3JtYXRpb24+KCk7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBvd25lcnNoaXBzID0gbmV3IE1hcDxzdHJpbmcsIEJ1Y2tldE93bmVyc2hpcD4oKTtcbiAgcHJpdmF0ZSByZWFkb25seSBlbmNyeXB0aW9ucyA9IG5ldyBNYXA8c3RyaW5nLCBCdWNrZXRFbmNyeXB0aW9uPigpO1xuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgYnVja2V0T3duZXJzaGlwKHMzOiBBV1MuUzMsIGJ1Y2tldDogc3RyaW5nKTogUHJvbWlzZTxCdWNrZXRPd25lcnNoaXA+IHtcbiAgICByZXR1cm4gY2FjaGVkKHRoaXMub3duZXJzaGlwcywgYnVja2V0LCAoKSA9PiB0aGlzLl9idWNrZXRPd25lcnNoaXAoczMsIGJ1Y2tldCkpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGJ1Y2tldEVuY3J5cHRpb24oczM6IEFXUy5TMywgYnVja2V0OiBzdHJpbmcpOiBQcm9taXNlPEJ1Y2tldEVuY3J5cHRpb24+IHtcbiAgICByZXR1cm4gY2FjaGVkKHRoaXMuZW5jcnlwdGlvbnMsIGJ1Y2tldCwgKCkgPT4gdGhpcy5fYnVja2V0RW5jcnlwdGlvbihzMywgYnVja2V0KSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9idWNrZXRPd25lcnNoaXAoczM6IEFXUy5TMywgYnVja2V0OiBzdHJpbmcpOiBQcm9taXNlPEJ1Y2tldE93bmVyc2hpcD4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBzMy5nZXRCdWNrZXRMb2NhdGlvbih7IEJ1Y2tldDogYnVja2V0IH0pLnByb21pc2UoKTtcbiAgICAgIHJldHVybiBCdWNrZXRPd25lcnNoaXAuTUlORTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5jb2RlID09PSAnTm9TdWNoQnVja2V0JykgeyByZXR1cm4gQnVja2V0T3duZXJzaGlwLkRPRVNfTk9UX0VYSVNUOyB9XG4gICAgICBpZiAoWydBY2Nlc3NEZW5pZWQnLCAnQWxsQWNjZXNzRGlzYWJsZWQnXS5pbmNsdWRlcyhlLmNvZGUpKSB7IHJldHVybiBCdWNrZXRPd25lcnNoaXAuU09NRU9ORV9FTFNFU19PUl9OT19BQ0NFU1M7IH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfYnVja2V0RW5jcnlwdGlvbihzMzogQVdTLlMzLCBidWNrZXQ6IHN0cmluZyk6IFByb21pc2U8QnVja2V0RW5jcnlwdGlvbj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbmNyeXB0aW9uID0gYXdhaXQgczMuZ2V0QnVja2V0RW5jcnlwdGlvbih7IEJ1Y2tldDogYnVja2V0IH0pLnByb21pc2UoKTtcbiAgICAgIGNvbnN0IGwgPSBlbmNyeXB0aW9uPy5TZXJ2ZXJTaWRlRW5jcnlwdGlvbkNvbmZpZ3VyYXRpb24/LlJ1bGVzPy5sZW5ndGggPz8gMDtcbiAgICAgIGlmIChsID4gMCkge1xuICAgICAgICBsZXQgc3NlYWxnbyA9IGVuY3J5cHRpb24/LlNlcnZlclNpZGVFbmNyeXB0aW9uQ29uZmlndXJhdGlvbj8uUnVsZXNbMF0/LkFwcGx5U2VydmVyU2lkZUVuY3J5cHRpb25CeURlZmF1bHQ/LlNTRUFsZ29yaXRobTtcbiAgICAgICAgaWYgKHNzZWFsZ28gPT09ICdBRVMyNTYnKSByZXR1cm4gQnVja2V0RW5jcnlwdGlvbi5TU0VBbGdvcml0aG1fQUVTMjU2O1xuICAgICAgICBpZiAoc3NlYWxnbyA9PT0gJ2F3czprbXMnKSByZXR1cm4gQnVja2V0RW5jcnlwdGlvbi5TU0VBbGdvcml0aG1fYXdzX2ttcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBCdWNrZXRFbmNyeXB0aW9uLk5PX0VOQ1JZUFRJT047XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUuY29kZSA9PT0gJ05vU3VjaEJ1Y2tldCcpIHtcbiAgICAgICAgcmV0dXJuIEJ1Y2tldEVuY3J5cHRpb24uRE9FU19OT1RfRVhJU1Q7XG4gICAgICB9XG4gICAgICBpZiAoZS5jb2RlID09PSAnU2VydmVyU2lkZUVuY3J5cHRpb25Db25maWd1cmF0aW9uTm90Rm91bmRFcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIEJ1Y2tldEVuY3J5cHRpb24uTk9fRU5DUllQVElPTjtcbiAgICAgIH1cblxuICAgICAgaWYgKFsnQWNjZXNzRGVuaWVkJywgJ0FsbEFjY2Vzc0Rpc2FibGVkJ10uaW5jbHVkZXMoZS5jb2RlKSkge1xuICAgICAgICByZXR1cm4gQnVja2V0RW5jcnlwdGlvbi5BQ0NFU19ERU5JRUQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gQnVja2V0RW5jcnlwdGlvbi5OT19FTkNSWVBUSU9OO1xuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjYWNoZWQ8QSwgQj4oY2FjaGU6IE1hcDxBLCBCPiwga2V5OiBBLCBmYWN0b3J5OiAoeDogQSkgPT4gUHJvbWlzZTxCPik6IFByb21pc2U8Qj4ge1xuICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSkhO1xuICB9XG5cbiAgY29uc3QgZnJlc2ggPSBhd2FpdCBmYWN0b3J5KGtleSk7XG4gIGNhY2hlLnNldChrZXksIGZyZXNoKTtcbiAgcmV0dXJuIGZyZXNoO1xufSJdfQ==